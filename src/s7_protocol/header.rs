use std::convert::TryFrom;

use crate::errors::{Error, S7ProtocolError};

// **** Message Types ****
// request sent by the master (e.g. read/write memory, read/write blocks, start/stop device, setup communication)
pub(crate) const JOB_REQUEST: u8 = 0x01;
// simple acknowledgement sent by the slave with no data field (I have never seen it sent by the S300/S400 devices)
pub(crate) const ACK: u8 = 0x02;
// acknowledgement with optional data field, contains the reply to a job request
pub(crate) const ACK_DATA: u8 = 0x03;
// an extension of the original protocol, the parameter field contains the request/response id, (used for programming/debugging, SZL reads, security functions, time setup, cyclic read..)
#[allow(dead_code)]
pub(crate) const USER_DATA: u8 = 0x07;

#[derive(Debug)]
pub(crate) struct S7ProtocolHeader {
    protocol_id: u8,    // protocol constant always set to 0x32
    message_type: u8,   // see above
    reserved: u16,      // always set to 0x0000 (but probably ignored)
    pdu_reference: u16, // generated by the master, incremented with each new transmission, used to link responses to their requests,
    // Little-Endian (note: this is the behavior of WinCC, Step7, and other Siemens programs,
    // it could probably be randomly generated, the PLC just copies it to the reply)
    parameter_length: u16,   // the length of the parameter field, Big-Endian
    data_length: u16,        // the length of the data field, Big-Endian
    error_class: Option<u8>, // only present in the Ack-Data messages, the possible error constants are listed in the constants.txt
    error_code: Option<u8>, // only present in the Ack-Data messages, the possible error constants are listed in the constants.txt
}

impl S7ProtocolHeader {
    pub(crate) fn build_request(
        pdu_ref: &mut u16,
        parameter_length: u16,
        data_length: u16,
    ) -> Self {
        // increase or reset counter for pdu reference
        *pdu_ref = if *pdu_ref == u16::MAX {
            0
        } else {
            *pdu_ref + 1
        };

        // build S7 protocol header
        Self {
            protocol_id: 0x32,
            message_type: JOB_REQUEST,
            reserved: 0x0000,
            pdu_reference: *pdu_ref,
            parameter_length,
            data_length,
            error_class: None,
            error_code: None,
        }
    }

    #[allow(dead_code)]
    pub(crate) fn is_ack(&self) -> Result<&Self, Error> {
        if self.message_type == ACK || self.message_type == ACK_DATA {
            Ok(self)
        } else {
            Err(Error::RequestNotAcknowledged)
        }
    }

    pub(crate) fn is_ack_with_data(&self) -> Result<&Self, Error> {
        match self.message_type == ACK_DATA {
            true => {
                // TODO CHECK FOR ERROR CODES
                if self.error_class.is_some() || self.error_code.is_some() {
                    Err(Error::S7ProtocolError(S7ProtocolError::from_codes(
                        self.error_class,
                        self.error_code,
                    )))
                } else {
                    Ok(self)
                }
            }
            false => Err(Error::RequestNotAcknowledged),
        }
    }

    pub(crate) fn is_current_pdu_response(&self, current_pdu_number: u16) -> Result<&Self, Error> {
        if self.pdu_reference == current_pdu_number {
            Ok(self)
        } else {
            Err(Error::ResponseDoesNotBelongToCurrentPDU)
        }
    }

    pub(crate) fn has_error(&self) -> bool {
        self.error_class.is_some() || self.error_code.is_some()
    }

    pub(crate) fn get_errors(&self) -> (Option<u8>, Option<u8>) {
        (self.error_class, self.error_code)
    }
}

impl From<S7ProtocolHeader> for Vec<u8> {
    fn from(header: S7ProtocolHeader) -> Vec<u8> {
        let mut vec = vec![header.protocol_id, header.message_type];
        vec.append(&mut header.reserved.to_be_bytes().to_vec());

        // IMPORTANT: Little-Endian
        vec.append(&mut header.pdu_reference.to_le_bytes().to_vec());

        vec.append(&mut header.parameter_length.to_be_bytes().to_vec());
        vec.append(&mut header.data_length.to_be_bytes().to_vec());

        if header.error_code.is_some() && header.error_class.is_some() {
            vec.append(&mut vec![
                header.error_class.unwrap(),
                header.error_code.unwrap(),
            ]);
        }
        vec
    }
}

impl TryFrom<Vec<u8>> for S7ProtocolHeader {
    type Error = Error;

    fn try_from(bytes: Vec<u8>) -> Result<Self, Self::Error> {
        match bytes.len() {
            10 | 12 => Ok(Self {
                protocol_id: bytes[0],
                message_type: bytes[1],
                reserved: u16::from_be_bytes([bytes[2], bytes[3]]),
                pdu_reference: u16::from_le_bytes([bytes[4], bytes[5]]),
                parameter_length: u16::from_be_bytes([bytes[6], bytes[7]]),
                data_length: u16::from_be_bytes([bytes[8], bytes[9]]),
                error_class: match bytes.len() {
                    12 => match bytes[10] {
                        0x0 => None,
                        _ => Some(bytes[10]),
                    },
                    _ => None,
                },
                error_code: match bytes.len() {
                    12 => match bytes[11] {
                        0x0 => None,
                        _ => Some(bytes[11]),
                    },
                    _ => None,
                },
            }),
            _ => Err(Error::TryFrom(
                bytes,
                "Invalid length for bytes of S7 Protocol header...".to_string(),
            )),
        }
    }
}
