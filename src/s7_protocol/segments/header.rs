use std::convert::TryFrom;

use bytes::{Buf, BufMut, BytesMut};

use crate::errors::{Error, IsoError, S7ProtocolError};

// **** Message Types ****
// request sent by the master (e.g. read/write memory, read/write blocks, start/stop device, setup communication)
pub(crate) const JOB_REQUEST: u8 = 0x01;
// simple acknowledgement sent by the slave with no data field (I have never seen it sent by the S300/S400 devices)
pub(crate) const ACK: u8 = 0x02;
// acknowledgement with optional data field, contains the reply to a job request
pub(crate) const ACK_DATA: u8 = 0x03;
// an extension of the original protocol, the parameter field contains the request/response id, (used for programming/debugging, SZL reads, security functions, time setup, cyclic read..)
#[allow(dead_code)]
pub(crate) const USER_DATA: u8 = 0x07;

#[derive(Debug)]
pub(crate) struct S7ProtocolHeader {
    protocol_id: u8,    // protocol constant always set to 0x32
    message_type: u8,   // see above
    reserved: u16,      // always set to 0x0000 (but probably ignored)
    pdu_reference: u16, // generated by the master, incremented with each new transmission, used to link responses to their requests,
    // Little-Endian (note: this is the behavior of WinCC, Step7, and other Siemens programs,
    // it could probably be randomly generated, the PLC just copies it to the reply)
    parameter_length: u16,   // the length of the parameter field, Big-Endian
    data_length: u16,        // the length of the data field, Big-Endian
    error_class: Option<u8>, // only present in the Ack-Data messages, the possible error constants are listed in the constants.txt
    error_code: Option<u8>, // only present in the Ack-Data messages, the possible error constants are listed in the constants.txt
}

impl S7ProtocolHeader {
    pub(crate) fn _len_request() -> usize {
        10
    }

    pub(crate) fn len_response() -> usize {
        12
    }

    pub(crate) fn build_request(
        pdu_ref: &mut u16,
        parameter_length: usize,
        data_length: usize,
    ) -> Result<Self, Error> {
        // increase or reset counter for pdu reference
        *pdu_ref = if *pdu_ref == u16::MAX {
            0
        } else {
            *pdu_ref + 1
        };

        // build S7 protocol header
        Ok(Self {
            protocol_id: 0x32,
            message_type: JOB_REQUEST,
            reserved: 0x0000,
            pdu_reference: *pdu_ref,
            parameter_length: u16::try_from(parameter_length)
                .map_err(|_| Error::TooManyItemsInOneRequest)?,
            data_length: u16::try_from(data_length).map_err(|_| Error::DataItemTooLarge)?,
            error_class: None,
            error_code: None,
        })
    }

    pub(crate) fn is_ack(&self) -> Result<&Self, Error> {
        if self.message_type == ACK || self.message_type == ACK_DATA {
            Ok(self)
        } else {
            Err(Error::RequestNotAcknowledged)
        }
    }

    pub(crate) fn is_ack_with_data(&self) -> Result<&Self, Error> {
        if self.message_type == ACK_DATA {
            let mut has_error = false;
            // check for error codes in response
            if let Some(class) = self.error_class {
                if class != 0 {
                    has_error = true;
                }
            }
            if let Some(code) = self.error_code {
                if code != 0 {
                    has_error = true;
                }
            }

            if has_error {
                Err(Error::S7ProtocolError(S7ProtocolError::from_codes(
                    self.error_class,
                    self.error_code,
                )))
            } else {
                Ok(self)
            }
        } else {
            Err(Error::RequestNotAcknowledged)
        }
    }

    pub(crate) fn is_current_pdu_response(&self, current_pdu_number: u16) -> Result<&Self, Error> {
        if self.pdu_reference == current_pdu_number {
            Ok(self)
        } else {
            Err(Error::ResponseDoesNotBelongToCurrentPDU)
        }
    }

    pub(crate) fn has_error(&self) -> bool {
        let mut has_error = false;
        // check for error codes in response
        if let Some(class) = self.error_class {
            if class != 0 {
                has_error = true;
            }
        }
        if let Some(code) = self.error_code {
            if code != 0 {
                has_error = true;
            }
        }

        has_error
    }

    pub(crate) fn get_errors(&self) -> (Option<u8>, Option<u8>) {
        (self.error_class, self.error_code)
    }
}

impl From<S7ProtocolHeader> for BytesMut {
    fn from(header: S7ProtocolHeader) -> BytesMut {
        let mut bytes = BytesMut::with_capacity(12);
        bytes.put_u8(header.protocol_id);
        bytes.put_u8(header.message_type);
        bytes.put_u16(header.reserved);
        // IMPORTANT: Little-Endian
        bytes.put_u16_le(header.pdu_reference);
        bytes.put_u16(header.parameter_length);
        bytes.put_u16(header.data_length);

        if header.error_code.is_some() && header.error_class.is_some() {
            bytes.put_u8(header.error_class.unwrap());
            bytes.put_u8(header.error_code.unwrap());
        }

        bytes
    }
}

impl TryFrom<&mut BytesMut> for S7ProtocolHeader {
    type Error = Error;

    fn try_from(bytes: &mut BytesMut) -> Result<Self, Self::Error> {
        // check if there are enough bytes for a header
        if bytes.len() >= 10 {
            let mut header = Self {
                protocol_id: bytes.get_u8(),
                message_type: bytes.get_u8(),
                reserved: bytes.get_u16(),
                // !!!! IMPORTANT to use Little-Endian
                pdu_reference: bytes.get_u16_le(),
                parameter_length: bytes.get_u16(),
                data_length: bytes.get_u16(),
                error_class: None,
                error_code: None,
            };

            // add error class and code if header is with data
            if header.message_type == ACK_DATA {
                header.error_class = Some(bytes.get_u8());
                header.error_code = Some(bytes.get_u8());
            };
            Ok(header)
        } else {
            Err(Error::ISOResponse(IsoError::ShortPacket))
        }
    }
}
